# lv


##### Description
manage LVM logical volume (LV)

##### Parameters

*   **`name`** (*required*): specify the name of the new LV

	>note: Without this option a default names of "lvol#" will be generated where # is the LVM internal number of the logical volume

*	**`vg-name`** (*required*): specify the volume group name which the new LV created from

*   **`path`** (*optional*): a list of physical volume path

		Example: /dev/sdk1, /dev/sdk2

	>note: VolumeGroup{Name|Path}[/ThinPoolLogicalVolumeName]
	   [PhysicalVolumePath[:PE[-PE]]...]

*   **`available`** (*optional*): specify the name of the new LV

		Example: y, ay, n, ey, en, ly, ln

	>note: Controls the availability of the Logical Volumes for immediate use after the command finishes running.  By default, new Logical Volumes are activated (-ay). If it is possible technically, -an will leave the new Logical Volume inactive. But for example, snapshots can only be created in the active state so -an cannot be used with --snapshot. Normally the --zero n argument has to be supplied too because zeroing (the default behaviour) also requires activation. If autoactivation option is used (-aay), the logical volume is activated only if it matches an item in the activation/auto_activation_volume_list set in lvm.conf. For autoactivated logical volumes, --zero n is always assumed and it can't be overridden. If clustered locking is enabled, -aey will activate exclusively on one node and -aly will activate only on the local node.

*   **`chunk-size`** (*optional*): speicy the size of chunk for snapshot and thin pool LV

	>note: For snapshots the value must be power of 2 between 4KiB and 512KiB and the default value is 4. For thin pools the value must be between 64KiB and 1048576KiB and the default value starts with 64 and scales up to fit the pool metadata size within 128MB, if the poolmetadata size is not specified. Older dm thin pool target version (<1.4) requires the value to be power of 2. The newer version requires to be the multiple of 64KiB, however discard is not supported for non power of 2 values.  Default unit is in kilobytes.

*   **`contiguous`** (*optional*): set or reset the contiguous allocation policy for LVs, by default ***`false`***

	>note: Default is no contiguous allocation based on a next free principle.

*   **`discards`** (*optional*): specify the discards behavior, by default ***`passdown`***

		Example: ignore, nopassdown, passdown

*   **`stripe-number`** (*optional*): specify the number of stripes

	>note: This is equal to the number of physical volumes to scatter the logical volume

*   **`stripe-size`** (*optional*): specify the number of kilobytes for the granularity of the stripes.

	>note: size must be 2^n (n = 2 to 9) for metadata in LVM1 format. For metadata in LVM2 format, the stripe size may be a  larger power of 2 but must not exceed the physical extent size

*   **`le-number`** (*optional*): specify the number of logical extents to allocate for the new LV

	>note: The number can also be expressed as a percentage of the total space in the Volume Group with the suffix %VG, as a percentage of the remaining free space in the Volume Group with the suffix %FREE, as a percentage of the remaining free space for the specified PhysicalVolume(s) with the suffix %PVS, or (for a snapshot) as a percentage of the total space in the Origin  Logical Volume with the suffix %ORIGIN

*   **`le-size`** (*optional*): specify the size to allocate for the new LV

	>note: A size suffix of K for kilobytes, M for megabytes, G for gigabytes, T for terabytes, P for petabytes or E for exabytes is optional. Default unit is megabytes

*   **`minor-number`** (*optional*): specify the minor number

*   **`persistent`** (*optional*): whether to make the minor number specified persistent or not, by default ***`false`***

*   **`mirror-number`** (*optional*): Create a mirrored LV with this number of copies

	>note: For example, specifying "-m 1" would result in a mirror with two- sides; that is, a linear volume plus one copy.

	>Specifying the optional argument --nosync will cause the creation of the mirror to skip the initial resynchronization. Any data written afterwards will be mirrored, but the original contents will not be copied. This is useful for skipping a potentially long and resource intensive initial sync of an empty device.

    >The optional argument --mirrorlog specifies the type of log to be used. The default is disk, which is persistent and requires a small amount of storage space, usually on a separate device from the data being mirrored. Using core means the mirror is regenerated by copying the data from the first device again each time the device is activated, for example, after every reboot. Using "mirrored" will create a persistent log that is itself mirrored.

	>The optional argument --corelog is equivalent to --mirrorlog core

*   **`no-udev-sync`** (*optional*): whether to disable udev synchronisation or not, by default ***`false`***

	>note: The process will not wait for notification from udev. It will continue irrespective of any possible udev processing in the background. You should only use this if udev is not running or has rules that ignore the devices LVM2 creates

*   **`monitor`** (*optional*): whether to monitor a mirrored or snapshot LV with dmeventd or not, if it is installed, by default ***`false`***

	>note: If a device used by a monitored mirror reports an I/O error, the failure is handled according to mirror_image_fault_policy and mirror_log_fault_policy set in lvm.conf

*   **`ignore-monitoring`** (*optional*): make no attempt to interact with dmeventd unless ***monitor*** is ***`true`*** ,by default ***`false`***

*   **`permission`** (*optional*): specify the access permissions to read only or read and write, by default ***RW***

		Example: r, rw

*   **`pool-metadata-size`** (*optional*): specify the size of thin pool's metadata LV

	>note: Supported value is in range between 2MiB and 16GiB. Default value is (Pool_LV_size / Pool_LV_chunk_size  *  64b).   Default unit is megabytes.

*   **`region-size`** (*optional*):

	>note: A mirror is divided into regions of this size (in MB), and the mirror log uses this granularity to track which regions are in sync.

*   **`readahead`** (*optional*): set read ahead sector count of this LV

		Example: ReadAheadSectors, auto, none

	>note: For volume groups with metadata in lvm1 format, this must be a value between 2 and 120. The default value is "auto" which allows the kernel to choose a suitable value automatically.  "None" is equivalent to specifying zero.

*   **`snapshot`** (*optional*): create a snapshot logical volume (or snapshot) for an existing, so called original logical volume (or origin)

	>note: Snapshots provide a 'frozen image' of the contents of the origin while the origin can still be updated. They enable consistent backups and online recovery of removed/overwritten data/files. Thin snapshot is created when the origin is a thin  volume and the size is not specified. Thin snapshot shares same blocks within the thin pool volume. The snapshot with the specified size does not need the same amount of storage the origin has. In a typical scenario, 15-20% might be enough.  In case the snapshot runs out of storage, use lvextend(8) to grow it. Shrinking a snapshot is supported by lvreduce(8) as well. Run  lvdisplay(8) on the snapshot in order to check how much data is allocated to it. Note that a small amount of the space you allocate to the snapshot is used to track the locations of the chunks of data, so you should allocate slightly more space than  you actually need and monitor the rate at which the snapshot data is growing so you can avoid running out of space

*   **`thinpool`** (*optional*): create thin pool or thin logical volume or both

		Example: ReadAheadSectors, auto, none

	>note: Specifying the optional argument --size will cause the creation of the thin pool logical volume. Specifying the optional argument --virtualsize will cause the creation of the thin logical volume from given thin pool volume. Specifying  both arguments will cause the creation of both thin pool and thin volume using this pool. Requires device mapper kernel driver for thin provisioning from kernel 3.2 or newer

*   **`type`** (*optional*): create a logical volume that uses the specified segment type, (e.g. `raid5`, `mirror`, `snapshot`, `thin`, `thin-pool`)

	>note: Many segment types have a commandline switch alias that will enable their use (-s is an alias for --type snapshot).   However, this argument must be used when no existing commandline switch alias is available for the desired type, as is the  case with error, zero, raid1, raid4, raid5 or raid6

*   **`virtual-size`** (*optional*): Create a sparse device of the given size (in MB by default) using a snapshot or thinly provisioned device when thin pool is specified.

	>note: Anything written to the device will be returned when reading from it. Reading from other areas of the device will return blocks of zeros. Virtual snapshot is implemented by creating a hidden virtual device of the requested size using the zero target. A suffix of _vorigin is used for this device.

*   **`zero`** (*optional*): whether to set zero of the first KB of data in the new LV or not, by default ***`true`***

	>note: Volume will not be zeroed if read only flag is set.

	>Snapshot volumes are zeroed always.

*   **`autobackup`** (*optional*): whether to metadata should be backed up automatically after a change or not, by default ***`true`***

	>note: You are strongly advised not to disable this! See vgcfgbackup(8)

*   **`tag`** (*optional*): add the tag to this VG

	>note: A tag is a word that can be used to group LVM2 objects of the same type together. Tags can be given on the command line in place of PV, VG or LV arguments. Tags should be prefixed with @ to avoid ambiguity. Each tag is expanded by replacing  it with all objects possessing that tag which are of the type expected by its position on the command line. PVs can only possess tags while they are part of a Volume Group: PV tags are discarded if the PV is removed from the VG. As an example, you could tag some LVs as database and others as userdata and then activate the database ones with lvchange -ay @database. Objects can possess multiple  tags  simultaneously. Only the new LVM2 metadata format supports tagging: objects using the LVM1 metadata format cannot be tagged because the on-disk format does not support it. Characters allowed in tags are: A-Z a-z 0-9 _ + . - and as of version 2.02.78 the following characters are also accepted: / = ! : # &

*   **`allocation-policy`** (*optional*): specify the allocation policy

		Example: contiguous, cling, normal, anywhere or inherit

	>note: When a command needs to allocate Physical Extents from the Volume Group, the allocation policy controls how they are chosen. Each Volume Group and Logical Volume has an allocation policy defined. The default for a Volume Group is normal which applies common-sense rules such as not placing parallel stripes on the same Physical Volume. The default for a Logical Volume is inherit which applies the same policy as for the Volume Group.  These policies can be changed using lvchange(8) and vgchange(8) or overridden on the command line of any command that performs allocation. The contiguous policy requires that new  Physical Extents be placed adjacent to existing Physical Extents. The cling policy places new Physical Extents on the same Physical Volume as existing Physical Extents in the same stripe of the Logical Volume. If there are sufficient free Physical Extents to satisfy an allocation request but normal doesn't use them, anywhere will - even if that reduces performance by placing two stripes on the same Physical Volume
				